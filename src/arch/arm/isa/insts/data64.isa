// -*- mode:c++ -*-

// Copyright (c) 2011-2013, 2016-2018 ARM Limited
// All rights reserved
//
// The license below extends only to copyright in the software and shall
// not be construed as granting a license to any other intellectual
// property including but not limited to intellectual property relating
// to a hardware implementation of the functionality of the software
// licensed hereunder.  You may use the software subject to the license
// terms below provided that you ensure that this notice is replicated
// unmodified and in its entirety in all distributions of the software,
// modified or unmodified, in source code or in binary form.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met: redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer;
// redistributions in binary form must reproduce the above copyright
// notice, this list of conditions and the following disclaimer in the
// documentation and/or other materials provided with the distribution;
// neither the name of the copyright holders nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Authors: Gabe Black

let {{

    header_output = ""
    decoder_output = ""
    exec_output = ""

    def createCcCode64(carry, overflow):
        code = ""
        code += '''
            uint16_t _iz, _in;
            _in = bits(resTemp, intWidth - 1);
            _iz = ((resTemp & mask(intWidth)) == 0);
            CondCodesNZ = (_in << 1) | _iz;
            DPRINTF(Arm, "(in, iz) = (%d, %d)\\n", _in, _iz);
        '''
        if overflow and overflow != "none":
            code +=  '''
                uint16_t _iv;
                _iv = %s & 1;
                CondCodesV = _iv;
                DPRINTF(Arm, "(iv) = (%%d)\\n", _iv);
            ''' % overflow
        if carry and carry != "none":
            code += '''
                uint16_t _ic;
                _ic = %s & 1;
                CondCodesC = _ic;
                DPRINTF(Arm, "(ic) = (%%d)\\n", _ic);
            ''' % carry
        return code

    oldC = 'CondCodesC'
    oldV = 'CondCodesV'
    # Dicts of ways to set the carry flag.
    carryCode64 = {
        "none": "none",
        "add": 'findCarry(intWidth, resTemp, Op164, secOp)',
        "chk": '0',
        "dpm": '0',
        "sub": 'findCarry(intWidth, resTemp, Op164, ~secOp)',
        "logic": '0'
    }
    # Dict of ways to set the overflow flag.
    overflowCode64 = {
        "none": "none",
        "add": 'findOverflow(intWidth, resTemp, Op164, secOp)',
        "chk": '0',
        "dpm": '0',
        "sub": 'findOverflow(intWidth, resTemp, Op164, ~secOp)',
        "logic": '0'
    }

    immOp2 = "uint64_t secOp M5_VAR_USED = imm;"
    sRegOp2 = "uint64_t secOp M5_VAR_USED = " + \
              "shiftReg64(Op264, shiftAmt, shiftType, intWidth);"
    eRegOp2 = "uint64_t secOp M5_VAR_USED = " + \
              "extendReg64(Op264, extendType, shiftAmt, intWidth);"

    def buildDataWork(mnem, code, flagType, suffix, buildCc, buildNonCc,
                      base, templateBase, overrideOpClass=None):
        code = '''
        uint64_t resTemp M5_VAR_USED = 0;
        ''' + code
        ccCode = createCcCode64(carryCode64[flagType], overflowCode64[flagType])
        Name = mnem.capitalize() + suffix
        
        if overrideOpClass:
            iop = InstObjParams(mnem, Name, base, 
                                { 'code': code, 'op_class': overrideOpClass})
            iopCc = InstObjParams(mnem + "s", Name + "Cc", base, 
                                  {'code': code + ccCode, 'op_class': overrideOpClass})
        else:
            iop = InstObjParams(mnem, Name, base, code)
            iopCc = InstObjParams(mnem + "s", Name + "Cc", base, code + ccCode)

        def subst(iop):
            global header_output, decoder_output, exec_output
            header_output += eval(templateBase + "Declare").subst(iop)
            decoder_output += eval(templateBase + "Constructor").subst(iop)
            exec_output += BasicExecute.subst(iop)

        if buildNonCc:
            subst(iop)
        if buildCc:
            subst(iopCc)

    def buildXImmDataInst(mnem, code, flagType = "logic", \
                          buildCc = True, buildNonCc = True, \
                          overrideOpClass=None, suffix = "XImm"):
        buildDataWork(mnem, immOp2 + code, flagType, suffix,
                      buildCc, buildNonCc, "DataXImmOp", "DataXImm", overrideOpClass)

    def buildXSRegDataInst(mnem, code, flagType = "logic", \
                           buildCc = True, buildNonCc = True, \
                           overrideOpClass=None, suffix = "XSReg"):
        buildDataWork(mnem, sRegOp2 + code, flagType, suffix,
                      buildCc, buildNonCc, "DataXSRegOp", "DataXSReg", overrideOpClass)

    def buildXERegDataInst(mnem, code, flagType = "logic", \
                           buildCc = True, buildNonCc = True, \
                           overrideOpClass=None, suffix = "XEReg"):
        buildDataWork(mnem, eRegOp2 + code, flagType, suffix,
                      buildCc, buildNonCc, "DataXERegOp", "DataXEReg", overrideOpClass)

    def buildDataInst(mnem, code, flagType = "logic",
                      buildCc = True, buildNonCc = True, overrideOpClass=None):
        buildXImmDataInst(mnem, code, flagType, buildCc, buildNonCc, overrideOpClass)
        buildXSRegDataInst(mnem, code, flagType, buildCc, buildNonCc, overrideOpClass)
        buildXERegDataInst(mnem, code, flagType, buildCc, buildNonCc, overrideOpClass)

    buildXImmDataInst("adr", "Dest64 = RawPC + imm", buildCc = False);
    buildXImmDataInst("adrp", "Dest64 = (RawPC & ~mask(12)) + imm",
                      buildCc = False);
    buildDataInst("and", "Dest64 = resTemp = Op164 & secOp;")
    buildDataInst("eor", "Dest64 = Op164 ^ secOp;", buildCc = False)
    buildXSRegDataInst("eon", "Dest64 = Op164 ^ ~secOp;", buildCc = False)
    buildDataInst("sub", "Dest64 = resTemp = Op164 - secOp;", "sub")
    buildDataInst("add", "Dest64 = resTemp = Op164 + secOp;", "add")
    
    buildDataInst("chk", """
        std::map<uint64_t, uint64_t> reram;

        // populate reram here
reram[42785280] = 0x9f7fffcdb0a4c42b;
reram[42785536] = 0xf23eeb8003003bc8;
reram[42785288] = 0x000b2005fc152112;
reram[42752096] = 0x0c2f21fa3defdefe;
reram[42785296] = 0x000000000000144f;
reram[42785768] = 0xc00106fffc104b4d;
reram[42752024] = 0x5ee2f02154d7f82b;
reram[42785312] = 0x7b001993c1256524;
reram[42784944] = 0x000000000000d312;
reram[42785320] = 0x09269802032dd0a0;
reram[42784816] = 0x00000000000094af;
reram[42785032] = 0x3feb823941983507;
reram[42784832] = 0x86f4d604382d3c1b;
reram[42784864] = 0xfc0802b24c0211a1;
reram[42785352] = 0x258c8b45a361ee12;
reram[42785360] = 0x0000000000009200;
reram[42785736] = 0x00d3000491102092;
reram[42752088] = 0x2efffdffa58b1ff3;
reram[42785376] = 0x0bc018bff8ec5427;
reram[42785552] = 0x0000000000007432;
reram[42752048] = 0x000000004d957ef9;
reram[42785384] = 0xf428f0005ccdc800;
reram[42784880] = 0x0000000000002044;
reram[42785128] = 0x1e985ff60202317d;
reram[42785328] = 0x000000000000feb2;
reram[42784936] = 0x3ff41c062192cdff;
reram[42784896] = 0x780948eefa007de0;
reram[42785472] = 0x363ff980012612d9;
reram[42752032] = 0x1f157ebd1d347409;
reram[42784904] = 0x801defff0009f8fc;
reram[42784912] = 0x0000000000001010;
reram[42752152] = 0xa5488024ca10f7d7;
reram[42785568] = 0x7277eec203006fc8;
reram[42785440] = 0x01c002feb0ff8007;
reram[42785136] = 0x0000000000005e80;
reram[42752016] = 0x5864f0213a28f828;
reram[42785448] = 0xc29afe009c01fc00;
reram[42752272] = 0xd6c0c490b98a261c;
reram[42785456] = 0x000000000000e001;
reram[42785480] = 0x180db807fc173424;
reram[42754864] = 0x0000000025bbf866;
reram[42784960] = 0x4cc01b6e844d5a30;
reram[42784800] = 0x0ac3cbcff88d9c2b;
reram[42785808] = 0x000000000000b2ff;
reram[42784968] = 0x2959000249bb6f06;
reram[42785416] = 0x1246b006905bfed2;
reram[42752160] = 0x27231c6ccae04042;
reram[42784976] = 0x0000000000000940;
reram[42754984] = 0xcbe2c243c8eac245;
reram[42755288] = 0x61575020841a0ebc;
reram[42754848] = 0xe5db7804cea057d2;
reram[42784992] = 0xde002780006ed8b8;
reram[42785488] = 0x0000000000006c00;
reram[42785792] = 0xcf3fe38056fc4138;
reram[42785512] = 0xc0006006fc01d9dd;
reram[42752240] = 0x0000000070595866;
reram[42785520] = 0x00000000000018ff;
reram[42784808] = 0xc001500efc9dc100;
reram[42784872] = 0x0143bdb6d001d6ff;
reram[42785024] = 0xd70017a1deed19a1;
reram[42785152] = 0x7c001386050217ff;
reram[42785776] = 0x000000000000183e;
reram[42785544] = 0x40040fffe5642f3a;
reram[42752224] = 0x2759586afa80ffd2;
reram[42785040] = 0x000000000000b380;
reram[42752216] = 0x820a869ce2795871;
reram[42785600] = 0xaec0b3864ffe40b2;
reram[42752880] = 0x00000000d3e0d840;
reram[42785056] = 0xcd401a9ff2ee5836;
reram[42785072] = 0x0000000000002bff;
reram[42785760] = 0xfebfef84d8e82a32;
reram[42785576] = 0x09000ffb201226be;
reram[42752208] = 0xea0046d0a00a861c;
reram[42785584] = 0x0000000000007610;
reram[42785160] = 0x240c0d37e931cc00;
reram[42785088] = 0xae0011dd060373c8;
reram[42785504] = 0x0d88137cb83c7826;
reram[42785744] = 0x00000000000019c9;
reram[42755056] = 0x000000006ff2f828;
reram[42785096] = 0x009a0ffffa003f7f;
reram[42785104] = 0x0000000000003f00;
reram[42785120] = 0xba00131c000373d0;
reram[42785168] = 0x0000000000006e00;
reram[42785728] = 0x4a990f4904f93554;
reram[42785640] = 0x008447fc83fe3a0d;
reram[42752176] = 0x0000000087a17c62;
reram[42785616] = 0x0000000000000036;
reram[42785648] = 0x0000000000003310;
reram[42785000] = 0x5267401ffe5a4b2d;
reram[42785200] = 0x000000000000140e;
reram[42752040] = 0x4fa23e7c7c3af02c;
reram[42752168] = 0xc2e05242e36b822c;
reram[42785064] = 0xc16bc008d6c98301;
reram[42785664] = 0xb4bff54d0103ddc9;
reram[42785344] = 0x533f633001b12269;
reram[42785672] = 0x13db43db43f832bf;
reram[42784928] = 0xb4c005e0031133b8;
reram[42755280] = 0x81931508e3504144;
reram[42785680] = 0x0000000000000800;
reram[42754968] = 0x4aecc343e1ead1d1;
reram[42785184] = 0x9f8003f008c0f07c;
reram[42785008] = 0x0000000000004b06;
reram[42785192] = 0x8003917cfc002403;
reram[42752144] = 0xcae4d1c2c2e091c5;
reram[42785712] = 0x00000000000080a7;
reram[42784840] = 0x403b70017d042904;
reram[42785424] = 0x000000000000c940;
reram[42785216] = 0x12fff4e5393e925b;
reram[42785696] = 0x17ffec6438bcc11f;
reram[42754992] = 0x00000000f9f24242;
reram[42785608] = 0xc40af6d8ec00406f;
reram[42785224] = 0xe4877ec82fd76480;
reram[42754856] = 0xca805fd2c0e28245;
reram[42785232] = 0x000000000000801f;
reram[42785800] = 0xe5e380bcfc007fdf;
reram[42785408] = 0x6b890ab2d6c0d3a1;
reram[42785632] = 0x99801d4b011173e8;
reram[42752080] = 0x277fdbf76dea5f66;
reram[42785248] = 0x92d25854191d34cf;
reram[42784848] = 0x0000000000007d92;
reram[42754976] = 0xa1f2c863dbe6c343;
reram[42785256] = 0xe448624ffc004125;
reram[42752112] = 0x000000009dd5a1ac;
reram[42785264] = 0x0000000000000312;
reram[42785704] = 0xc01ff000000b0000;
reram[42752104] = 0xfade77ed337d9fe7;
reram[42785392] = 0x000000000000d4f7;
reram[42752232] = 0x5da3f062ca0106d4;

        Dest64 = resTemp = (reram.find(secOp) == reram.end()) ? secOp : __builtin_popcountll(~(Op164^reram[secOp]));

        // uncoment this to do profiling
        // printf(\"%lu,\", secOp);

        // uncomment this to debug
        // printf(\"Called CHK\\n\");
        // printf(\"->  Op164: %lx\\n\", Op164);
        // printf(\"->  secOp: %lx\\n\", reram[secOp]);
        // printf(\"-> Dest64: %lx\\n\", Dest64);
        """,
        "chk", overrideOpClass="CusAluOp")

    buildDataInst("dpm", """
        Dest64 = resTemp = __builtin_popcountll(~(Op164^secOp));

        // uncoment this to do profiling
        // printf(\"%lu\\n\", secOp);

        // uncomment this to debug
        // printf(\"Called DPM\\n\");
        // printf(\"-> Op164: %lx\\n\", Op164);
        // printf(\"-> secOp: %lx\\n\", secOp);
        """,
        "dpm", overrideOpClass="CusAluOp")
    
    buildXSRegDataInst("adc",
            "Dest64 = resTemp = Op164 + secOp + %s;" % oldC, "add")
    buildXSRegDataInst("sbc",
            "Dest64 = resTemp = Op164 - secOp - !%s;" % oldC, "sub")
    buildDataInst("orr", "Dest64 = Op164 | secOp;", buildCc = False)
    buildXSRegDataInst("orn", "Dest64 = Op164 | ~secOp;", buildCc = False)
    buildXSRegDataInst("bic", "Dest64 = resTemp = Op164 & ~secOp;")

    def buildDataXImmInst(mnem, code, optArgs = []):
        global header_output, decoder_output, exec_output
        classNamePrefix = mnem[0].upper() + mnem[1:]
        templateBase = "DataXImm"
        iop = InstObjParams(mnem, classNamePrefix + "64",
                            templateBase + "Op", code, optArgs)
        header_output += eval(templateBase + "Declare").subst(iop)
        decoder_output += eval(templateBase + "Constructor").subst(iop)
        exec_output += BasicExecute.subst(iop)

    def buildDataXRegInst(mnem, regOps, code, optArgs = [],
                          overrideOpClass=None):
        global header_output, decoder_output, exec_output
        templateBase = "DataX%dReg" % regOps
        classNamePrefix = mnem[0].upper() + mnem[1:]
        if overrideOpClass:
            iop = InstObjParams(mnem, classNamePrefix + "64",
                                templateBase + "Op",
                                { 'code': code, 'op_class': overrideOpClass},
                                optArgs)
        else:
            iop = InstObjParams(mnem, classNamePrefix + "64",
                                templateBase + "Op", code, optArgs)
        header_output += eval(templateBase + "Declare").subst(iop)
        decoder_output += eval(templateBase + "Constructor").subst(iop)
        exec_output += BasicExecute.subst(iop)

    buildDataXRegInst("madd", 3, "Dest64 = Op164 + Op264 * Op364",
        overrideOpClass="IntMultOp")
    buildDataXRegInst("msub", 3, "Dest64 = Op164 - Op264 * Op364",
        overrideOpClass="IntMultOp")
    buildDataXRegInst("smaddl", 3,
        "XDest = XOp1 + sext<32>(WOp2) * sext<32>(WOp3)",
        overrideOpClass="IntMultOp")
    buildDataXRegInst("smsubl", 3,
        "XDest = XOp1 - sext<32>(WOp2) * sext<32>(WOp3)",
        overrideOpClass="IntMultOp")
    buildDataXRegInst("smulh", 2, '''
        uint64_t op1H = (int32_t)(XOp1 >> 32);
        uint64_t op1L = (uint32_t)XOp1;
        uint64_t op2H = (int32_t)(XOp2 >> 32);
        uint64_t op2L = (uint32_t)XOp2;
        uint64_t mid1 = ((op1L * op2L) >> 32) + op1H * op2L;
        uint64_t mid2 = op1L * op2H;
        uint64_t result = ((uint64_t)(uint32_t)mid1 + (uint32_t)mid2) >> 32;
        result += shiftReg64(mid1, 32, ASR, intWidth);
        result += shiftReg64(mid2, 32, ASR, intWidth);
        XDest = result + op1H * op2H;
    ''', overrideOpClass="IntMultOp")
    buildDataXRegInst("umaddl", 3, "XDest = XOp1 + WOp2 * WOp3",
        overrideOpClass="IntMultOp")
    buildDataXRegInst("umsubl", 3, "XDest = XOp1 - WOp2 * WOp3",
        overrideOpClass="IntMultOp")
    buildDataXRegInst("umulh", 2, '''
        uint64_t op1H = (uint32_t)(XOp1 >> 32);
        uint64_t op1L = (uint32_t)XOp1;
        uint64_t op2H = (uint32_t)(XOp2 >> 32);
        uint64_t op2L = (uint32_t)XOp2;
        uint64_t mid1 = ((op1L * op2L) >> 32) + op1H * op2L;
        uint64_t mid2 = op1L * op2H;
        uint64_t result = ((uint64_t)(uint32_t)mid1 + (uint32_t)mid2) >> 32;
        result += mid1 >> 32;
        result += mid2 >> 32;
        XDest = result + op1H * op2H;
    ''', overrideOpClass="IntMultOp")

    buildDataXRegInst("asrv", 2,
        "Dest64 = shiftReg64(Op164, Op264, ASR, intWidth)")
    buildDataXRegInst("lslv", 2,
        "Dest64 = shiftReg64(Op164, Op264, LSL, intWidth)")
    buildDataXRegInst("lsrv", 2,
        "Dest64 = shiftReg64(Op164, Op264, LSR, intWidth)")
    buildDataXRegInst("rorv", 2,
        "Dest64 = shiftReg64(Op164, Op264, ROR, intWidth)")

    crcCode = '''
    constexpr uint8_t size_bytes = %(sz)d;
    constexpr uint32_t poly = %(polynom)s;

    // Initial value is often a previously evaluated
    // crc value hence is always 32bit in CRC32
    uint32_t initial_crc = Op164 & 0xFFFFFFFF;

    uint64_t data = htole(Op264);
    auto data_buffer = reinterpret_cast<uint8_t*>(&data);

    Dest = crc32<poly>(
        data_buffer,   /* Message register */
        initial_crc,   /* Initial value of the CRC */
        size_bytes     /* Size of the original Message */
    );
    '''
    buildDataXRegInst("crc32b", 2,
        crcCode % {"sz": 1, "polynom": "0x04C11DB7"})
    buildDataXRegInst("crc32h", 2,
        crcCode % {"sz": 2, "polynom": "0x04C11DB7"})
    buildDataXRegInst("crc32w", 2,
        crcCode % {"sz": 4, "polynom": "0x04C11DB7"})
    buildDataXRegInst("crc32x", 2,
        crcCode % {"sz": 8, "polynom": "0x04C11DB7"})

    buildDataXRegInst("crc32cb", 2,
        crcCode % {"sz": 1, "polynom": "0x1EDC6F41"})
    buildDataXRegInst("crc32ch", 2,
        crcCode % {"sz": 2, "polynom": "0x1EDC6F41"})
    buildDataXRegInst("crc32cw", 2,
        crcCode % {"sz": 4, "polynom": "0x1EDC6F41"})
    buildDataXRegInst("crc32cx", 2,
        crcCode % {"sz": 8, "polynom": "0x1EDC6F41"})

    buildDataXRegInst("sdiv", 2, '''
        int64_t op1 = Op164;
        int64_t op2 = Op264;
        if (intWidth == 32) {
            op1 = sext<32>(op1);
            op2 = sext<32>(op2);
        }
        Dest64 = op2 == -1 ? -op1 : op2 ? op1 / op2 : 0;
    ''', overrideOpClass="IntDivOp")
    buildDataXRegInst("udiv", 2, "Dest64 = Op264 ? Op164 / Op264 : 0",
        overrideOpClass="IntDivOp")

    buildDataXRegInst("cls", 1, '''
        uint64_t op1 = Op164;
        if (bits(op1, intWidth - 1))
            op1 ^= mask(intWidth);
        Dest64 = (op1 == 0) ? intWidth - 1 : (intWidth - 2 - findMsbSet(op1));
    ''')
    buildDataXRegInst("clz", 1, '''
        Dest64 = (Op164 == 0) ? intWidth : (intWidth - 1 - findMsbSet(Op164));
    ''')
    buildDataXRegInst("rbit", 1, '''
        Dest64 = reverseBits(Op164, intWidth/8);
    ''')
    buildDataXRegInst("rev", 1, '''
        if (intWidth == 32)
            Dest64 = betole<uint32_t>(Op164);
        else
            Dest64 = betole<uint64_t>(Op164);
    ''')
    buildDataXRegInst("rev16", 1, '''
        int count = intWidth / 16;
        uint64_t result = 0;
        for (unsigned i = 0; i < count; i++) {
            uint16_t hw = Op164 >> (i * 16);
            result |= (uint64_t)betole<uint16_t>(hw) << (i * 16);
        }
        Dest64 = result;
    ''')
    buildDataXRegInst("rev32", 1, '''
        int count = intWidth / 32;
        uint64_t result = 0;
        for (unsigned i = 0; i < count; i++) {
            uint32_t hw = Op164 >> (i * 32);
            result |= (uint64_t)betole<uint32_t>(hw) << (i * 32);
        }
        Dest64 = result;
    ''')

    msrMrs64EnabledCheckCode = '''
        // Check for read/write access right
        if (!can%sAArch64SysReg(flat_idx, Scr64, cpsr, xc->tcBase())) {
            if (flat_idx == MISCREG_DAIF ||
                flat_idx == MISCREG_DC_ZVA_Xt ||
                flat_idx == MISCREG_DC_CVAC_Xt ||
                flat_idx == MISCREG_DC_CIVAC_Xt
                )
                return std::make_shared<UndefinedInstruction>(
                                    machInst, 0, EC_TRAPPED_MSR_MRS_64,
                                    mnemonic);
            return std::make_shared<UndefinedInstruction>(machInst, false,
                                                          mnemonic);
        }

        fault = this->trap(xc->tcBase(), flat_idx, el, imm);
        if (fault != NoFault) return fault;
    '''

    mrsCode = '''
        MiscRegIndex flat_idx = (MiscRegIndex) xc->tcBase()->
            flattenRegId(RegId(MiscRegClass, op1)).index();
        CPSR cpsr = Cpsr;
        ExceptionLevel el = (ExceptionLevel) (uint8_t) cpsr.el;
        %s
        XDest = MiscOp1_ud;
    ''' % (msrMrs64EnabledCheckCode % ('Read'),)

    mrsIop = InstObjParams("mrs", "Mrs64", "RegMiscRegImmOp64",
                           mrsCode,
                           ["IsSerializeBefore"])
    header_output += RegMiscRegOp64Declare.subst(mrsIop)
    decoder_output += RegMiscRegOp64Constructor.subst(mrsIop)
    exec_output += BasicExecute.subst(mrsIop)

    buildDataXRegInst("mrsNZCV", 1, '''
        CPSR cpsr = 0;
        cpsr.nz = CondCodesNZ;
        cpsr.c = CondCodesC;
        cpsr.v = CondCodesV;
        XDest = cpsr;
    ''')

    msrCode = '''
        MiscRegIndex flat_idx = (MiscRegIndex) xc->tcBase()->
            flattenRegId(RegId(MiscRegClass, dest)).index();
        CPSR cpsr = Cpsr;
        ExceptionLevel el = (ExceptionLevel) (uint8_t) cpsr.el;
        %s
        MiscDest_ud = XOp1;
    ''' % (msrMrs64EnabledCheckCode % ('Write'),)

    msrIop = InstObjParams("msr", "Msr64", "MiscRegRegImmOp64",
                           msrCode,
                           ["IsSerializeAfter", "IsNonSpeculative"])
    header_output += MiscRegRegOp64Declare.subst(msrIop)
    decoder_output += MiscRegRegOp64Constructor.subst(msrIop)
    exec_output += BasicExecute.subst(msrIop)


    buildDataXRegInst("msrNZCV", 1, '''
        CPSR cpsr = XOp1;
        CondCodesNZ = cpsr.nz;
        CondCodesC = cpsr.c;
        CondCodesV = cpsr.v;
    ''')

    msr_check_code = '''
        MiscRegIndex flat_idx = (MiscRegIndex) xc->tcBase()->
            flattenRegId(RegId(MiscRegClass, dest)).index();
        CPSR cpsr = Cpsr;
        ExceptionLevel el = (ExceptionLevel) (uint8_t) cpsr.el;
        %s
    ''' % (msrMrs64EnabledCheckCode % ('Write'),)


    msrdczva_ea_code = msr_check_code
    msrdczva_ea_code += '''
           Request::Flags memAccessFlags = Request::CACHE_BLOCK_ZERO |
               ArmISA::TLB::MustBeOne;
           EA = XBase;
           assert(!(Dczid & 0x10));
           uint64_t op_size = power(2, Dczid + 2);
           EA &= ~(op_size - 1);

   '''

    msrDCZVAIop = InstObjParams("dc zva", "Dczva", "SysDC64",
                                { "ea_code" : msrdczva_ea_code,
                                  "memacc_code" : ';',
                                  "use_uops" : 0,
                                  "op_wb" : ";",
                                  "fa_code" : ";"},
                                ['IsStore', 'IsMemRef']);
    header_output += DCStore64Declare.subst(msrDCZVAIop);
    decoder_output += DCStore64Constructor.subst(msrDCZVAIop);
    exec_output += DCStore64Execute.subst(msrDCZVAIop);
    exec_output += DCStore64InitiateAcc.subst(msrDCZVAIop);
    exec_output += Store64CompleteAcc.subst(msrDCZVAIop);


    msrdccvau_ea_code = msr_check_code
    msrdccvau_ea_code += '''
           Request::Flags memAccessFlags = Request::CLEAN | Request::DST_POU |
              ArmISA::TLB::MustBeOne;
           EA = XBase;
           System *sys = xc->tcBase()->getSystemPtr();
           Addr op_size = sys->cacheLineSize();
           EA &= ~(op_size - 1);
    '''

    msrDCCVAUIop = InstObjParams("dc cvau", "Dccvau", "SysDC64",
                                 { "ea_code" : msrdccvau_ea_code,
                                   "memacc_code" : ';',
                                   "use_uops" : 0,
                                   "op_wb" : ";", "fa_code" : ";"},
                                 ['IsStore', 'IsMemRef']);
    header_output += DCStore64Declare.subst(msrDCCVAUIop);
    decoder_output += DCStore64Constructor.subst(msrDCCVAUIop);
    exec_output += DCStore64Execute.subst(msrDCCVAUIop);
    exec_output += DCStore64InitiateAcc.subst(msrDCCVAUIop);
    exec_output += Store64CompleteAcc.subst(msrDCCVAUIop);


    msrdccvac_ea_code = msr_check_code
    msrdccvac_ea_code += '''
           Request::Flags memAccessFlags = Request::CLEAN | Request::DST_POC |
              ArmISA::TLB::MustBeOne;
           EA = XBase;
           System *sys = xc->tcBase()->getSystemPtr();
           Addr op_size = sys->cacheLineSize();
           EA &= ~(op_size - 1);
    '''

    msrDCCVACIop = InstObjParams("dc cvac", "Dccvac", "SysDC64",
                                 { "ea_code" : msrdccvac_ea_code,
                                   "memacc_code" : ';',
                                   "use_uops" : 0,
                                   "op_wb" : ";", "fa_code" : ";"},
                                 ['IsStore', 'IsMemRef']);
    header_output += DCStore64Declare.subst(msrDCCVACIop);
    decoder_output += DCStore64Constructor.subst(msrDCCVACIop);
    exec_output += DCStore64Execute.subst(msrDCCVACIop);
    exec_output += DCStore64InitiateAcc.subst(msrDCCVACIop);
    exec_output += Store64CompleteAcc.subst(msrDCCVACIop);


    msrdccivac_ea_code = msr_check_code
    msrdccivac_ea_code += '''
           Request::Flags memAccessFlags = Request::CLEAN |
              Request::INVALIDATE | Request::DST_POC | ArmISA::TLB::MustBeOne;
           EA = XBase;
           System *sys = xc->tcBase()->getSystemPtr();
           Addr op_size = sys->cacheLineSize();
           EA &= ~(op_size - 1);
    '''

    msrDCCIVACIop = InstObjParams("dc civac", "Dccivac", "SysDC64",
                                  { "ea_code" : msrdccivac_ea_code,
                                    "memacc_code" : ';',
                                    "use_uops" : 0,
                                    "op_wb" : ";", "fa_code" : ";"},
                                  ['IsStore', 'IsMemRef']);
    header_output += DCStore64Declare.subst(msrDCCIVACIop);
    decoder_output += DCStore64Constructor.subst(msrDCCIVACIop);
    exec_output += DCStore64Execute.subst(msrDCCIVACIop);
    exec_output += DCStore64InitiateAcc.subst(msrDCCIVACIop);
    exec_output += Store64CompleteAcc.subst(msrDCCIVACIop);


    msrdcivac_ea_code = msr_check_code
    msrdcivac_ea_code += '''
           Request::Flags memAccessFlags = Request::INVALIDATE |
              Request::DST_POC | ArmISA::TLB::MustBeOne;
           EA = XBase;
           HCR hcr = Hcr64;
           SCR scr = Scr64;
           if (el == EL1 && ArmSystem::haveVirtualization(xc->tcBase()) &&
               hcr.vm && (scr.ns || !ArmSystem::haveSecurity(xc->tcBase()))) {
               memAccessFlags = memAccessFlags | Request::CLEAN;
           }
           System *sys = xc->tcBase()->getSystemPtr();
           Addr op_size = sys->cacheLineSize();
           EA &= ~(op_size - 1);
    '''

    msrDCIVACIop = InstObjParams("dc ivac", "Dcivac", "SysDC64",
                                 { "ea_code" : msrdcivac_ea_code,
                                   "memacc_code" : ';',
                                   "use_uops" : 0,
                                   "op_wb" : ";", "fa_code" : ";"},
                                 ['IsStore', 'IsMemRef']);
    header_output += DCStore64Declare.subst(msrDCIVACIop);
    decoder_output += DCStore64Constructor.subst(msrDCIVACIop);
    exec_output += DCStore64Execute.subst(msrDCIVACIop);
    exec_output += DCStore64InitiateAcc.subst(msrDCIVACIop);
    exec_output += Store64CompleteAcc.subst(msrDCIVACIop);


    buildDataXImmInst("msrSP", '''
        if (!canWriteAArch64SysReg(
                (MiscRegIndex) xc->tcBase()->flattenRegId(
                   RegId(MiscRegClass, dest)).index(),
                Scr64, Cpsr, xc->tcBase())) {
            return std::make_shared<UndefinedInstruction>(machInst, false,
                                                          mnemonic);
        }
        MiscDest_ud = imm;
    ''', optArgs = ["IsSerializeAfter", "IsNonSpeculative"])

    buildDataXImmInst("msrDAIFSet", '''
        if (!canWriteAArch64SysReg(
                (MiscRegIndex) xc->tcBase()->flattenRegId(
                   RegId(MiscRegClass, dest)).index(),
                Scr64, Cpsr, xc->tcBase())) {
            return std::make_shared<UndefinedInstruction>(
                            machInst, 0, EC_TRAPPED_MSR_MRS_64,
                            mnemonic);
        }
        CPSR cpsr = Cpsr;
        cpsr.daif = cpsr.daif | imm;
        Cpsr = cpsr;
    ''', optArgs = ["IsSerializeAfter", "IsNonSpeculative"])

    buildDataXImmInst("msrDAIFClr", '''
        if (!canWriteAArch64SysReg(
                (MiscRegIndex) xc->tcBase()->flattenRegId(
                   RegId(MiscRegClass, dest)).index(),
                Scr64, Cpsr, xc->tcBase())) {
            return std::make_shared<UndefinedInstruction>(
                                machInst, 0, EC_TRAPPED_MSR_MRS_64,
                                mnemonic);
        }
        CPSR cpsr = Cpsr;
        cpsr.daif = cpsr.daif & ~imm;
        Cpsr = cpsr;
    ''', optArgs = ["IsSerializeAfter", "IsNonSpeculative"])

    def buildDataXCompInst(mnem, instType, suffix, code):
        global header_output, decoder_output, exec_output
        templateBase = "DataXCond%s" % instType
        iop = InstObjParams(mnem, mnem.capitalize() + suffix + "64",
                            templateBase + "Op", code)
        header_output += eval(templateBase + "Declare").subst(iop)
        decoder_output += eval(templateBase + "Constructor").subst(iop)
        exec_output += BasicExecute.subst(iop)

    def buildDataXCondImmInst(mnem, code):
        buildDataXCompInst(mnem, "CompImm", "Imm", code)
    def buildDataXCondRegInst(mnem, code):
        buildDataXCompInst(mnem, "CompReg", "Reg", code)
    def buildDataXCondSelInst(mnem, code):
        buildDataXCompInst(mnem, "Sel", "", code)

    def condCompCode(flagType, op, imm):
        ccCode = createCcCode64(carryCode64[flagType], overflowCode64[flagType])
        opDecl = "uint64_t secOp M5_VAR_USED = imm;"
        if not imm:
            opDecl = "uint64_t secOp M5_VAR_USED = Op264;"
        return opDecl + '''
            if (testPredicate(CondCodesNZ, CondCodesC, CondCodesV, condCode)) {
                uint64_t resTemp = Op164 ''' + op + ''' secOp;
        ''' + ccCode + '''
            } else {
                CondCodesNZ = (defCc >> 2) & 0x3;
                CondCodesC = (defCc >> 1) & 0x1;
                CondCodesV = defCc & 0x1;
            }
        '''

    buildDataXCondImmInst("ccmn", condCompCode("add", "+", True))
    
    buildDataXCondImmInst("ccmc", condCompCode("chk", "+", True))
    buildDataXCondImmInst("ccmm", condCompCode("dpm", "+", True))

    buildDataXCondImmInst("ccmp", condCompCode("sub", "-", True))
    
    buildDataXCondRegInst("ccmn", condCompCode("add", "+", False))
    
    buildDataXCondRegInst("ccmc", condCompCode("chk", "+", False))
    buildDataXCondRegInst("ccmm", condCompCode("dpm", "+", False))
    
    buildDataXCondRegInst("ccmp", condCompCode("sub", "-", False))

    condSelCode = '''
        if (testPredicate(CondCodesNZ, CondCodesC, CondCodesV, condCode)) {
            Dest64 = Op164;
        } else {
            Dest64 = %(altVal)s;
        }
    '''
    buildDataXCondSelInst("csel", condSelCode % {"altVal" : "Op264"})
    buildDataXCondSelInst("csinc", condSelCode % {"altVal" : "Op264 + 1"})
    buildDataXCondSelInst("csinv", condSelCode % {"altVal" : "~Op264"})
    buildDataXCondSelInst("csneg", condSelCode % {"altVal" : "-Op264"})
}};
